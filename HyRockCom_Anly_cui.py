# -*- coding: utf-8 -*-
"""
Data Reduction for Firing Test of Hybrid Rocket Using Re-construction Method

@author: T.J.-LAB-PC
"""

import os, sys
import copy
import json
import numpy as np
import pandas as pd
from cea_db_maker import cea_exe
from cea_db_maker import cea_pre
from cea_db_maker import cea_post
from rt import rt_1
from rt import rt_1_error
from rt import rt_2
from rt import rt_2_error
from rt import rt_3
from rt import rt_3_error
from rt import rt_4
from rt import rt_4_error
from rt import rt_5
from rt import rt_5_error
from rt import rt_2_hybrid
from rt import rt_2_patch
from rt import ntrt
import matplotlib.pyplot as plt


class RT():
    """
    Class executing re-construction technique and acquiering calculated results.
    
    Parameters
    ---------
    inst: class
        instance generated by "Cui_input()" class
        
    Class variable
    --------------
    self.of: 1-d ndarray
        list of oxidizer to fuel ratio calculated by CEA
    
    self.Pc: 1-d ndarray
        list of chamber pressure by CEA
        
    self.ex_df: pandas.DataFrame
        data frame of experimet data

    self.cstr: function
        function of characteristic exhaust velocity: self.cstr(of, Pc)
        
    self.gamma: function
        function of specific heat ratio at the end of chamber: self.gamma(of, Pc)
    """
    def __init__(self, inst):
        self.inst = inst
        self.of = inst.cea_db.of #range of O/F in the database calculated by CEA
        self.Pc = inst.cea_db.Pc #range of Chamber Pressure in the database calculated by CEA
        self.ex_df = inst.ex_df #Data Frame of experiment data
        self.input_param = inst.input_param
        self.cstr = inst.cea_db.gen_func("CSTAR") #data-base of characteristics exhaust velocity
        self.gamma = inst.cea_db.gen_func("GAMMAs_c") #data-base of specific heat ratio at chamber
        
    def call_rt(self):
        """ Execute RT and return the analized data as data frame
        
        Return
        -------
        anl_df: DataFrame
            analized data with using Re-construction technique
        """
        print("\nNow executing RT calculation. Please wait.")
        if self.input_param["mode"] == 1:
            anl_df = rt_1.Main(self.ex_df, self.input_param)
            if self.input_param["mode_error"] == "y":
                # anl_df = self.error_cal_rt1(anl_df)
                anl_df = rt_1_error.main(anl_df, self.ex_df, self.input_param)
                
#        if self.input_param["mode"] == 2:
#            anl_df = rt_2.main(self.ex_df, self.of, self.Pc, self.cstr, self.gamma, self.input_param)
        if self.input_param["mode"] == 2:
            anl_df = rt_2.Main(self.ex_df, self.cstr, self.gamma, self.input_param).execute_RT()
            if self.input_param["mode_error"] == "y":
                # anl_df = self.error_cal_rt5(anl_df)
                anl_df = rt_2_error.main(anl_df, self.ex_df, self.input_param, self.cstr, self.gamma)

        if self.input_param["mode"] == 3:
            anl_df = rt_3.Main(self.ex_df, self.cstr, self.gamma, self.input_param).execute_RT()
            if self.input_param["mode_error"] == "y":
                # anl_df = self.error_cal_rt3(anl_df)
                anl_df = rt_3_error.main(anl_df, self.ex_df, self.input_param, self.cstr, self.gamma)

        if self.input_param["mode"] == 4:
            anl_df = rt_4.Main(self.ex_df, self.cstr, self.gamma, self.input_param).execute_RT()
            if self.input_param["mode_error"] == "y":
                # anl_df = self.error_cal_rt3(anl_df)
                anl_df = rt_4_error.main(anl_df, self.ex_df, self.input_param, self.cstr, self.gamma)     

        if self.input_param["mode"] == 5:
            anl_df = rt_5.Main(self.ex_df, self.cstr, self.gamma, self.input_param).execute_RT()
            if self.input_param["mode_error"] == "y":
                # anl_df = self.error_cal_rt5(anl_df)
                anl_df = rt_5_error.main(anl_df, self.ex_df, self.input_param, self.cstr, self.gamma)

        if self.input_param["mode"] == 6:
            anl_df = rt_2_hybrid.Main(self.ex_df, self.cstr, self.gamma, self.input_param).execute_RT(filter_level=self.input_param["filterlv"])
            # if self.input_param["mode_error"] == "y":
                # anl_df = self.error_cal_rt5(anl_df)
                # anl_df = rt_5_error.main(anl_df, self.ex_df, self.input_param, self.cstr, self.gamma)

        if self.input_param["mode"] == 7:
            anl_df = rt_2_patch.Main(self.ex_df, self.cstr, self.gamma, self.input_param).execute_RT(filter_level=self.input_param["filterlv"])
            # if self.input_param["mode_error"] == "y":
                # anl_df = self.error_cal_rt5(anl_df)
                # anl_df = rt_5_error.main(anl_df, self.ex_df, self.input_param, self.cstr, self.gamma)

        if self.input_param["mode"] == 10:
            anl_df = ntrt.Main(self.ex_df, self.cstr, self.gamma, self.input_param).execute_RT()
            # if self.input_param["mode_error"] == "y":
                # anl_df = self.error_cal_rt5(anl_df)
                # anl_df = rt_5_error.main(anl_df, self.ex_df, self.input_param, self.cstr, self.gamma)

        self.anl_df = anl_df
        print("\nRT Calculation was successfully finished!")
        return(self.anl_df)


class Cui_input():
    """
    Class to attract information through CUI to execute RT calculation
    
    Class variable
    ----------
    self._langlist_: list ["jp","en",...]
        Contain initial two characters of language name.
    
    self._sntns_df_ : dict {outer_key: innerdict, ...}
        outer_key: string\n
            it is representative of the questionaire type. \n
        innerdict: string\n
            it is a questionaier sentense.

    self._lang_: string
        Selected language from the "_langlist_"
        
    self.ex_path: string
        Path containing experiment data
    
    self.ex_file: string
        The name of experimant data file (.csv)
        
    self.ex_param: dict {param_name: symbol}
        Parameter dictionary
        param_name: string; e.g., time [s], Oxidizer mass flow rate [kg/s], ...
        symbol: string; e.g., t, mox, ... 
        
    self.ex_df: DataFrame
        Data frame of measured parameter in an experiment
    
    self.input_param: dict{key, value}
        key: str, "mode"
        value: int, 1, 3, 4, 5
        the value is reperesentative number,
        1: RT-1, Re-construction technique 1; using average c*
        2: RT-2, Re-construction technique 5; using constant c* efficiency
        3: RT-3, Re-construction technique 3; using constant nozzle discharge coefficient lambda1 
        4: RT-4, Re-construction technique 4; using constant thrust deduction coefficnet lambda2 
        5: RT-5, Re-construction technique 5; using constant c* efficiency and using O/F calculated by RT-1 in c* calculation
        
        key: str, "Dt"
        value: float, nozzle throat diameter [m]
        
        key: str, "eps"
        value: float, nozzle expansion ratio [-]
        
        key: str, "Mf"
        value: float, fuel consumption [kg]
    
    self.cea_path: string
        Path containing the results of cea calculation
   
        
    """
    _langlist_ = ["jp","en"]
    _tmp_ = dict()
    _tmp_["oxid"] = {"jp": "\n\n計算オプション(0~2)を選択してください．\n例: 0: 全域平衡計算\n    1: 燃焼器内のみ平衡計算\n    2: スロートまで平衡計算",
                     "en": "\n\nPlease select option (0-2) of calculation.\ne.g.: 0: equilibrium during expansion\n      1: frozen after the end of chamber\n      2: frozen after nozzle throat"}

    def __init__(self):
        self._sntns_df_ = pd.DataFrame([], columns=self._langlist_)
        for i in self._tmp_:
            self._sntns_df_ = self._sntns_df_.append(pd.DataFrame(self._tmp_[i], index=[i]))
#        self._inp_lang_()
        self._get_expath_()
        self.input_param = dict()
        flag, cond_dict = self._select_cond_()
        if flag:
            self.input_param = cond_dict
            foldername = self.input_param["cea_db"]
            cadir = os.path.dirname(os.path.abspath(__file__))
            self.cea_path = os.path.join(cadir, "cea_db_maker", "cea_db", foldername, "csv_database")
        else:
            self._select_mode_()
            if (self.input_param["mode"] == 6) or (self.input_param["mode"] == 7):
                self._input_filterlv_()
            if (self.input_param["mode"] == 10):
                self._input_nozzle_initial_()
                self._input_nozzle_final_()
                self._input_nozzle_exit_()
            else:
                self._input_nozzle_()
                self._input_eps_()
            self._input_consump_()
            if (self.input_param["mode"] == 1) or (self.input_param["mode"] == 2) or (self.input_param["mode"] == 3) or \
            (self.input_param["mode"] == 4) or (self.input_param["mode"] == 5) :
                flag_error = self._select_error_analysis_()
            else:
                flag_error = False
            if flag_error:
                self._input_error_Pc_()
                self._input_error_mox_()
                self._input_error_Mf_()
                self._input_error_Dt_()
                if self.input_param["mode"] == 3 or self.input_param["mode"] == 4:
                    self._input_error_F_()
            else:
                pass
            self._get_ceapath_()
        self.cea_db = cea_post.Read_datset(self.cea_path)
        self._cond_out_()

    def _inp_lang_(self):
        """
        Select user language
        """
        print("Please select language.\n{}".format(self._langlist_))
        lang = input()
        if lang in self._langlist_:
            self._lang_ = lang
        else:
            print("There is no such language set!")

    def _get_expath_(self):
        """
        Get the experiment folder path, file name and data and, create template file to contain an experimental data
            ex_path: string, folder path 
            ex_file: string, file name
            ex_df: data frame of experintal data
            ex_param: dictionary of experimental data
        """
        cadir = os.path.dirname(os.path.abspath(__file__))
        while(True):
            foldername = input("\nInput a Experiment Name (The Name of Folder Containing Experiment Data in \"exp_dat\" folder) \n>>")
            self.ex_path = os.path.join(cadir, "exp_dat" ,foldername)
            if os.path.exists(self.ex_path):
                self.ex_file = "ex_dat.csv"
                file_path = os.path.join(self.ex_path, self.ex_file)
                p_name = ("time [s]", "Oxidizer mass flow rate [g/s]", "Thrust [N]", "Chamber pressure [MPaG]")
                symbol = ("t", "mox", "F", "Pc")
                self.ex_param = dict(zip(p_name, symbol))
                if os.path.exists(file_path):
                    self.ex_df = pd.read_csv(file_path,header=1, index_col=0, usecols=[0,1,2,3])
                    self.ex_df.mox = self.ex_df.mox * 1.0e-3 #convert [g/s] to [kg/s]
                    self.ex_df.Pc = self.ex_df.Pc * 1.0e+6 + 0.1013e+6 #convert [MPaG] to [Pa]
                    break
                else: # create template file
                    print("\nThere is no such a experiment data\n{}".format(file_path))
                    flag = input("\nDo you want to make a template file ?\n  y/n ?\n>>")
                    if flag == "y":
                        df = pd.DataFrame(self.ex_param, index=[0], columns=p_name)
                        df.to_csv(file_path, index= False)
                        print("\nComplete to generate a template file. \nPlease input the experimental data.")
                        print("Please aboid using any negative values and data that has vivration with time")
                    elif flag == "n":
                        sys.exit()
            else:
                print("There is no such a Folder\n{}".format(self.ex_path))           
    
    def _select_cond_(self):
        """
        Select whether using values contained in "cond.json" file
        
        Return
        -------
        flag: bool
            True: using the values
            False: don't use the values
        cond_dict: dict
            dictionary wihch contains the condition values
        """
        cond_dict = dict([])
        cond_path = os.path.join(self.ex_path, "cond.json")
        if os.path.exists(cond_path):
            cond_json = open(cond_path, "r")
            cond_dict = json.load(cond_json)
            while(True):
                print("\nDo you want to use following values contained in \"cond.json\"?")
                print(cond_dict)
                char = input("  y/n ?\n>>")
                if char == "y":
                    flag = True
                    break
                elif char == "n":
                    flag = False
                    break
                else:
                    pass
        else:
            flag = False
        return(flag, cond_dict)
        
    def _select_error_analysis_(self):
        """
        Select whether execute error analysys or not
        
        Return
        ------
        flag: bool
            True: execute error analisys
            False: don't execute error analisys
        """
        while(True):
            print("\nDo you want to execute error analisys?")
            char = input("  y/n ?\n>>")
            if char == "y":
                flag = True
                self.input_param["mode_error"] = "y"
                break
            elif char == "n":
                flag = False
                self.input_param["mode_error"] = "n"
                break
            else:
                pass
        return(flag)
        
           
    def _select_mode_(self):
        """
        Select a calculation mode; RT-1,2,3,4,5,...
        """
        while(True):
            print("\nSelect calculation mode.")
            mode = {1: "RT-1",
                    2: "RT-2",
                    3: "RT-3",
                    4: "RT-4",
                    5: "RT-5",
                    6: "RT-2 Hybrid",
                    7: "RT-2 Patch",
                    10: "NTRT"}
            inp = int(input(" 1: RT-1; assuming c* is constant\n"+\
                  " 2: RT-2;        assuming c* efficiency is constant\n"+\
                  " 3: RT-3;        assuming nozzle discharge coefficient is constant; lambda1\n"+\
                  " 4: RT-4;        assuming thrust deduction coefficnet is constant; lambda2\n"+\
                  " 5: RT-5;        assuming constant c* efficiency and using O/F calculated by RT-1 at c* calculation\n"+\
                  " 6: RT-2 Hybrid; hybrid method which swicth RT-2 to RT-5 at multi solution region (ver. beta)\n"+\
                  " 7: RT-2 Patch;  enable patch mode at multi solution region (ver. beta)\n"+\
                  "10: NTRT;        Nozzle throat reconstruction technique (developping)\n>>"))
            if inp in mode.keys():
                self.input_param["mode"] = inp
                break
            else:
                print("There is no such a mode \"{}\"\n".format(inp))

    def _input_filterlv_(self):
        """ Input the filter level 1~
        """
        self.input_param["filterlv"] = float(input("\nInput filter level at multi solution region. 1.0~\n>>"))

    def _input_nozzle_(self):
        """
        Input the nozzle diameter [mm]
        """
#        print("Please input nozzle throat diameter [mm]\n>>")
        self.input_param["Dt"] = float(input("\nInput nozzle throat diameter [mm]\n>>"))*1.0e-3

    def _input_nozzle_initial_(self):
        """
        Input the initial nozzle diameter [mm]
        """
#        print("Please input nozzle throat diameter [mm]\n>>")
        self.input_param["Dt_ini"] = float(input("\nInput initial nozzle throat diameter [mm]\n>>"))*1.0e-3

    def _input_nozzle_final_(self):
        """
        Input the final nozzle diameter [mm]
        """
#        print("Please input nozzle throat diameter [mm]\n>>")
        self.input_param["Dt_fin"] = float(input("\nInput final nozzle throat diameter [mm]\n>>"))*1.0e-3

    def _input_nozzle_exit_(self):
        """
        Input the final nozzle diameter [mm]
        """
#        print("Please input nozzle throat diameter [mm]\n>>")
        self.input_param["De"] = float(input("\nInput nozzle exit diameter [mm]\n>>"))*1.0e-3

    def _input_eps_(self):
        """
        Input the nozzle expansion ratio [-]
        """
#        print("Please input nozzle expansion ratio")
        self.input_param["eps"] = float(input("\nInput nozzle expansion ratio\n>>"))
        
    def _input_consump_(self):
        """
        Input the fuel consumption [g]
        """
#        print("Please input fuel consumption [g]")
        self.input_param["Mf"] = float(input("\nInput fuel consumption [g]\n>>"))*1.0e-3
    
    def _input_error_Pc_(self):
        """
        Input the error of pressure sensor which measures chamber pressure [Pa]
        """
        self.input_param["dPc"] = float(input("\nInput error of pressure sensor wihch measures chamber pressue [MPa]\n>>"))*1.0e+6

    def _input_error_mox_(self):
        """
        Input the error of oxidizer pass flow rate [kg/s]
        """
        self.input_param["dmox"] = float(input("\nInput error of oxidizer mass flow rate [g/s]\n>>"))*1.0e-3

    def _input_error_F_(self):
        """
        Input the error of load cell which measures thrust [N]
        """
        self.input_param["dF"] = float(input("\nInput error of load cell which measures thrust [N]\n>>"))

    def _input_error_Mf_(self):
        """
        Input the error of total fuel mass consumption [kg]
        """
        self.input_param["dMf"] = float(input("\nInput error of fuel mass consumption [g]\n>>"))*1.0e-3

    def _input_error_Dt_(self):
        """
        Input the error of nozzle throat diamter [m]
        """
        self.input_param["dDt"] = float(input("\nInput error of nozzle throat diameter [mm]\n>>"))*1.0e-3

    
    def _get_ceapath_(self):
        """
        Return the folder path cantaining the results of cea calculation.
            cea.path: string, folder path containing "out" folder
        """
        cadir = os.path.dirname(os.path.abspath(__file__))
        while(True):
            foldername = input("\nInput the Folder Name Containing Results of CEA in \"cea_db\" folder \n>>")
            self.cea_path = os.path.join(cadir, "cea_db_maker", "cea_db", foldername, "csv_database")
            if os.path.exists(self.cea_path):
                self.input_param["cea_db"] = foldername
                break
            else:
                print("\nThere is no such a dataset folder/n{}".format(self.cea_path))
                flag = input("\nDo you want to make a dataset of CEA result ?\n  y/n \n>>")
                if flag == "y":
                    print("\nInput some information to generate \".inp\" files to execute CEA.")
                    generate_class = cea_pre.Cui_input()
                    fld_path = generate_class.gen_all()
                    print("\nNow doing CEA calculation and output csv type data-base files. Please wait.")
                    execute_class = cea_exe.CEA_execute(fld_path=fld_path)
                    execute_class.all_exe()
                    break
                elif flag == "n":
                    pass
                
    def _cond_out_(self):
        """
        Output the input value as condition file: "cond.json"
        """
        output_fname = open(os.path.join(self.ex_path, "cond.json"), "w")
        json.dump(self.input_param, output_fname)



class Plot:
    """Class to plot the calculation result of RT

    Attributes
    ----------
    ex_path: string
        Folder's path which contains "result.csv": analysis folder name

    result_path: string
        File path of "result.csv"

    anl_df: pandas.DataFrame
        Data Frame of calculation result converted from "result.csv"
    """
    def __init__(self, ex_path):
        """        
        Parameters
        ----------
        ex_path : string
            Folder's path which contains "result.csv"
        """
        self.ex_path = ex_path
        self.result_path = os.path.join(self.ex_path, "result.csv")
        self._read_df_()
        
    def _read_df_(self):
        """Convert result.csv to pandas.DataFrame as anl_df
        """
        self.anl_df = pd.read_csv(self.result_path, header=0, index_col=0)

    def get_col_name(self):
        """Read out column name of result DataFrame
        
        Return
        -------
        list_col: list
            list which contains columns name of result DataFrame
        """
        list_col = list(self.anl_df.columns)
        print(list_col)
        return list_col

    def gen_graph(self, params1, params2=False, xlim=False, ylim1=False, ylim2=False, fname=False):

        """Plot the assigned parameters
        
        Parameters
        ----------
        params1 : tuple(string, ...)
            This tuple contains parameter's name chosed from column name of result DataFrame. And plot the graph on the first y-axis. 

        params2 : tuple(string, ...)
            This tuple contains parameter's name chosed from column name of result DataFrame. And plot the graph on the second y-axis. 

        xlim: tuple(float1, flota2)
            Assign the x-axis range from float1 to float2.

        ylim1: tuple(float1, flota2)
            Assign the y1-axis range from float1 to float2.

        ylim2: tuple(float1, flota2)
            Assign the y2-axis range from float1 to float2.

        fname: string; default=False
            Eport file name as graph picture. If name is not assigned, picuture file will not be exported.
        """
        dic_params = {"mox": (1.0e+3, "g/s", "Oxidizer mass flow rate"),
                      "F": (1.0, "N", "Thrust"),
                      "Pc": (1.0e-6, "MPa", "Chamber pressure"),
                      "gamma": (1.0, "-", "Specific heat ratio"),
                      "cstr_th": (1.0, "m/s", "Theoretical specific exhaust velocity"),
                      "of": (1.0, "-", "O/F"),
                      "mf": (1.0e+3, "g/s", "Fuel mass flow rate"),
                      "lambda": (1.0, "-", "Nozzle coefficient"),
                      "Pe": (1.0e-6, "MPa", "Nozzle exit pressure"),
                      "Ve": (1.0, "m/s", "Effective exhaust velocity"),
                      "cstr_ex": (1.0, "m/s", "Experimental specific exhaust velocity"),
                      "eta": (1.0, "-", "Specific exhaust velocity coefficient"),
                      "dof": (1.0, "-", "Error of O/F"),
                      "dmf": (1.0e+3, "g/s", "Error of fuel mass flow rate")}
        non_params = []
        for name in params1+params2:
            if name not in list(self.anl_df.columns):
                non_params.append(name)
        if len(non_params) != 0:
            print("{} are not include in the result.\nPlease select parameter from the following list".format(non_params))
        else:
            ylabel1 = str()
            ylabel2 = str()
            fig = plt.figure()
            ax1 = fig.add_subplot(111)
            for name in params1:
                ax1.plot(self.anl_df[name]*dic_params[name][0], "-", label=name)
                ylabel1 = ylabel1 + "{} [{}], ".format(name, dic_params[name][1])
            ax1.set_xlabel("Time [s]")
            ax1.set_ylabel(ylabel1)
            if params2:
                ax2 = ax1.twinx()
                for name in params2:
                    ax2.plot(self.anl_df[name]*dic_params[name][0], "--", label=name)
                    ylabel2 = ylabel2 + "{} [{}], ".format(name, dic_params[name][1])
                ax2.set_ylabel(ylabel2)
                if ylim2:
                    ax2.set_ylim(ylim2[0], ylim2[1])
                h1, l1 = ax1.get_legend_handles_labels()
                h2, l2 = ax2.get_legend_handles_labels()
                ax1.legend(h1+h2, l1+l2)
            else:
                ax1.legend()
            if xlim:
                ax1.set_xlim(xlim[0], xlim[1])
            if ylim1:
                ax1.set_ylim(ylim1[0], ylim1[1])

            if fname:
                gfile_path = os.path.join(self.ex_path, fname)
                plt.savefig(gfile_path, dpi=300)



if __name__ == "__main__":
    inst = Cui_input()
    df = RT(inst).call_rt()
    df.to_csv(os.path.join(inst.ex_path, "result.csv"))

    ex_path = inst.ex_path
    plot = Plot(ex_path)
    # plot.gen_graph(("of",))

    
